params {
    sampleFile = null
    sampleFileFormat = null
    sequencingType = null
    outputDir = null
    referenceGenome = null
    referenceGenomeFasta = null
    vepCache = null
	vepCpu = 2
    broad = null
    intervalsFile = 'interval_long_local.list'
    TSfilterSNP = '99.0'
    TSfilterINDEL = '99.0'

    hardFilters = [[name: 'QD2', expression: 'QD < 2.0'],
                   [name: 'QD1', expression: 'QD < 1.0'],
                   [name: 'QUAL30', expression: 'QUAL < 30.0'],
                   [name: 'SOR3', expression: 'SOR > 3.0'],
                   [name: 'FS60', expression: 'FS > 60.0'],
                   [name: 'MQ40', expression: 'MQ < 40.0'],
                   [name: 'MQRankSum-12.5', expression: 'MQRankSum < -12.5'],
                   [name: 'ReadPosRankSum-8', expression: 'ReadPosRankSum < -8.0']]

	max_memory	= 	8.GB
	max_time	= 	1.h
	max_cpus	=	2
	max_disk	= 	10.GB

}

profiles {
    debug {
        dumpHashes              = true
        process.beforeScript    = 'echo $HOSTNAME'
        cleanup                 = false
        nextflow.enable.configProcessNamesValidation = true
    }
    conda {
        conda.enabled           = true
        docker.enabled          = false
        singularity.enabled     = false
        podman.enabled          = false
        shifter.enabled         = false
        charliecloud.enabled    = false
        conda.channels          = ['conda-forge', 'bioconda', 'defaults']
        apptainer.enabled       = false
    }
    mamba {
        conda.enabled           = true
        conda.useMamba          = true
        docker.enabled          = false
        singularity.enabled     = false
        podman.enabled          = false
        shifter.enabled         = false
        charliecloud.enabled    = false
        apptainer.enabled       = false
    }
    docker {
        docker.enabled          = true
        conda.enabled           = false
        singularity.enabled     = false
        podman.enabled          = false
        shifter.enabled         = false
        charliecloud.enabled    = false
        apptainer.enabled       = false
        docker.runOptions       = '-u $(id -u):$(id -g)'
    }
    arm {
        docker.runOptions       = '-u $(id -u):$(id -g) --platform=linux/amd64'
    }
    singularity {
        singularity.enabled     = true
        singularity.autoMounts  = true
        conda.enabled           = false
        docker.enabled          = false
        podman.enabled          = false
        shifter.enabled         = false
        charliecloud.enabled    = false
        apptainer.enabled       = false
    }
    podman {
        podman.enabled          = true
        conda.enabled           = false
        docker.enabled          = false
        singularity.enabled     = false
        shifter.enabled         = false
        charliecloud.enabled    = false
        apptainer.enabled       = false
    }
    shifter {
        shifter.enabled         = true
        conda.enabled           = false
        docker.enabled          = false
        singularity.enabled     = false
        podman.enabled          = false
        charliecloud.enabled    = false
        apptainer.enabled       = false
    }
    charliecloud {
        charliecloud.enabled    = true
        conda.enabled           = false
        docker.enabled          = false
        singularity.enabled     = false
        podman.enabled          = false
        shifter.enabled         = false
        apptainer.enabled       = false
    }
    apptainer {
        apptainer.enabled       = true
        apptainer.autoMounts    = true
        conda.enabled           = false
        docker.enabled          = false
        singularity.enabled     = false
        podman.enabled          = false
        shifter.enabled         = false
        charliecloud.enabled    = false
    }
    wave {
        apptainer.ociAutoPull   = true
        singularity.ociAutoPull = true
        wave.enabled            = true
        wave.freeze             = true
        wave.strategy           = 'conda,container'
    }
    gitpod {
        executor.name           = 'local'
        executor.cpus           = 4
        executor.memory         = 8.GB
    }
    test      { includeConfig 'conf/test.config'      }
    test_full { includeConfig 'conf/test_full.config' }
}

docker {
    enabled = true
    docker.runOptions = '-u $(id -u):$(id -g)'
}

wave {
  enabled = false
}

fusion {
  enabled = false
  exportStorageCredentials = true
  logLevel = "trace"
}

process {
	container = 'ubuntu'
	executor = 'local'
	disk = 40.GB

	withName: 'excludeMNPs|splitMultiAllelics' {
		container = 'staphb/bcftools:1.19'
	}
	withName: 'importGVCF|genotypeGVCF_multi|genotypeGVCF_solo|genotypeGVCF|variantRecalibratorSNP|variantRecalibratorIndel|applyVQSRIndel|applyVQSRSNP|hardFiltering|gatherVCF' {
		container = 'broadinstitute/gatk:4.5.0.0'
	}
	withName: vep {
		container = 'ensemblorg/ensembl-vep:release_111.0'
	}
	withName: tabix {
		container = 'staphb/htslib:1.19'
	}

	withName: 'excludeMNPs' {
		errorStrategy = 'retry'
		maxRetries = 1
		cpus	=	{ check_max( 2 		* task.attempt, 'cpus' 		) 	}
		memory	=	{ check_max( 16.GB 	* task.attempt, 'memory'	) 	}
		disk	=	{ check_max( 50.GB 	* task.attempt, 'disk' 		)	}
		time	=	{ check_max( 8.h  	* task.attempt, 'time' 		)	}
	}
	withName: 'importGVCF' {
		errorStrategy = 'retry'
		maxRetries = 1
		cpus	=	{ check_max( 4		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 16.GB	* task.attempt, 'memory'	) 	}
		disk	=	{ check_max( 80.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 8.h	* task.attempt, 'time'		)	}
	}
	withName: 'genotypeGVCF' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus' 		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory' 	) 	}
		disk	=	{ check_max( 40.GB	* task.attempt, 'disk' 		)	}
		time	=	{ check_max( 8.h	* task.attempt, 'time' 		)	}
	}
	withName: 'variantRecalibrator.*|apply.*' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 30.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h	* task.attempt, 'time'		)	}
	}
	withName: 'splitMultiAllelics' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 30.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h	* task.attempt, 'time'		)	}
	}
	withName: 'tabix' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 30.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h	* task.attempt, 'time'		)	}
	}
	withName: 'vep' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 4 		* task.attempt, 'cpus'		)	}
		memory	=	{ check_max( 16.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 80.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h 	* task.attempt, 'time'		)	}
	}
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}