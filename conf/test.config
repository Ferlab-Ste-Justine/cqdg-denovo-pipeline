params {
    sampleFile = 'data-test/data/testSample.csv'
    sampleFileFormat = 'V2'
    sequencingType = 'WGS'
    outputDir = 'results'
    referenceGenome = 'data-test/reference/Homo_sapiens_assembly38/chr22'
    referenceGenomeFasta = 'chr22.fa'
    vepCache = 'data-test/reference/annotation/.vep'
	vepCpu = '2'
    broad = 'data-test/reference/broad'
    intervalsFile = 'interval_long_local.list'
    TSfilterSNP = '99.0'
    TSfilterINDEL = '99.0'

    hardFilters = [[name: 'QD2', expression: 'QD < 2.0'],
                   [name: 'QD1', expression: 'QD < 1.0'],
                   [name: 'QUAL30', expression: 'QUAL < 30.0'],
                   [name: 'SOR3', expression: 'SOR > 3.0'],
                   [name: 'FS60', expression: 'FS > 60.0'],
                   [name: 'MQ40', expression: 'MQ < 40.0'],
                   [name: 'MQRankSum-12.5', expression: 'MQRankSum < -12.5'],
                   [name: 'ReadPosRankSum-8', expression: 'ReadPosRankSum < -8.0']]

	max_memory	= 	8.GB
	max_time	= 	1.h
	max_cpus	=	2
	max_disk	= 	10.GB

}

docker {
    enabled = true
    docker.runOptions = '-u $(id -u):$(id -g)'
}

wave {
  enabled = false
}

fusion {
  enabled = false
  exportStorageCredentials = true
  logLevel = "trace"
}

process {
	container = 'ubuntu'
	executor = 'local'
	disk = 40.GB

	withName: 'excludeMNPs|splitMultiAllelics' {
		container = 'staphb/bcftools:1.19'
	}
	withName: 'importGVCF|genotypeGVCF_multi|genotypeGVCF_solo|genotypeGVCF|variantRecalibratorSNP|variantRecalibratorIndel|applyVQSRIndel|applyVQSRSNP|hardFiltering|gatherVCF' {
		container = 'broadinstitute/gatk:4.5.0.0'
	}
	withName: vep {
		container = 'ensemblorg/ensembl-vep:release_111.0'
	}
	withName: tabix {
		container = 'staphb/htslib:1.19'
	}

	withName: 'excludeMNPs' {
		errorStrategy = 'retry'
		maxRetries = 1
		cpus	=	{ check_max( 2 		* task.attempt, 'cpus' 		) 	}
		memory	=	{ check_max( 16.GB 	* task.attempt, 'memory'	) 	}
		disk	=	{ check_max( 50.GB 	* task.attempt, 'disk' 		)	}
		time	=	{ check_max( 8.h  	* task.attempt, 'time' 		)	}
	}
	withName: 'importGVCF' {
		errorStrategy = 'retry'
		maxRetries = 1
		cpus	=	{ check_max( 4		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 16.GB	* task.attempt, 'memory'	) 	}
		disk	=	{ check_max( 80.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 8.h	* task.attempt, 'time'		)	}
	}
	withName: 'genotypeGVCF' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus' 		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory' 	) 	}
		disk	=	{ check_max( 40.GB	* task.attempt, 'disk' 		)	}
		time	=	{ check_max( 8.h	* task.attempt, 'time' 		)	}
	}
	withName: 'variantRecalibrator.*|apply.*' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 30.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h	* task.attempt, 'time'		)	}
	}
	withName: 'splitMultiAllelics' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 30.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h	* task.attempt, 'time'		)	}
	}
	withName: 'tabix' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 2		* task.attempt, 'cpus'		) 	}
		memory	=	{ check_max( 14.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 30.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h	* task.attempt, 'time'		)	}
	}
	withName: 'vep' {
		errorStrategy = 'retry'
		maxRetries = 2
		cpus	=	{ check_max( 4 		* task.attempt, 'cpus'		)	}
		memory	=	{ check_max( 16.GB	* task.attempt, 'memory'	)	}
		disk	=	{ check_max( 80.GB	* task.attempt, 'disk'		)	}
		time	=	{ check_max( 10.h 	* task.attempt, 'time'		)	}
	}
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}